!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_PROGRAM_VERSION	5.8	//
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
CC	Makefile	/^CC = gcc$/;"	m
CXXFLAGS	Makefile	/^CXXFLAGS = -g $/;"	m
OBJS	Makefile	/^OBJS = server.o deviceMessage.o device.o socketTools.o epollTools.o register.o hash.o detectTimeOut.o userMessage.o pooledBuffer.o$/;"	m
TARGET	Makefile	/^TARGET = server$/;"	m
detectTimeOutThread	detectTimeOut.c	/^void *detectTimeOutThread()$/;"	f
initTimeOutThread	detectTimeOut.c	/^int initTimeOutThread()$/;"	f
DETECT_INTERVAL	detectTimeOut.h	22;"	d
TIMEOUT_DEBUG	detectTimeOut.h	18;"	d
TIMEOUT_INTERVAL	detectTimeOut.h	21;"	d
_DETECT_TIME_OUT_H	detectTimeOut.h	4;"	d
createDevice	device.c	/^deviceNode* createDevice(int sockfd)$/;"	f
deleteDevice	device.c	/^void deleteDevice(deviceNode* device, int epfd)$/;"	f
findDevice	device.c	/^deviceNode* findDevice(deviceTable *dt, char *deviceID)$/;"	f
findDevicePrior	device.c	/^deviceNode* findDevicePrior(deviceTable *dt, char *deviceID)$/;"	f
initDeviceTable	device.c	/^int initDeviceTable(int dtlen)$/;"	f
insertDevice	device.c	/^void insertDevice(deviceTable *dt, char *deviceID, deviceNode *newDevice)$/;"	f
smartDeviceTable	device.c	/^deviceTable *smartDeviceTable;			\/* device table *\/$/;"	v
tableHashKey	device.c	/^unsigned int tableHashKey(deviceTable *dt, char *deviceID)$/;"	f
updateDevice	device.c	/^int updateDevice(deviceTable *dt, char *deviceID, char *password, long long lastHeartBeatTime)$/;"	f
DEVICEID_SIZE	device.h	16;"	d
DEVICETABLE_SIZE	device.h	17;"	d
PASSWORD_SIZE	device.h	15;"	d
_DEVICE_H	device.h	4;"	d
deviceId	device.h	/^	char deviceId[DEVICEID_SIZE+1];		\/* deviceId *\/$/;"	m	struct:deviceNode
deviceList	device.h	/^typedef struct deviceList$/;"	s
deviceList	device.h	/^}deviceList;$/;"	t	typeref:struct:deviceList
deviceNode	device.h	/^typedef struct deviceNode$/;"	s
deviceNode	device.h	/^}deviceNode;$/;"	t	typeref:struct:deviceNode
deviceSockfd	device.h	/^	int deviceSockfd;					\/* socket fd of device *\/$/;"	m	struct:deviceNode
deviceTable	device.h	/^typedef struct deviceTable$/;"	s
deviceTable	device.h	/^}deviceTable;$/;"	t	typeref:struct:deviceTable
hashMask	device.h	/^	int hashMask;						\/* mask of hashï¼Œequals to size-1 *\/$/;"	m	struct:deviceTable
head	device.h	/^	deviceNode head;					\/* head of current list *\/$/;"	m	struct:deviceList
lastHeartBeatTime	device.h	/^	long long lastHeartBeatTime;		\/* timestamp of last heartbeat message *\/$/;"	m	struct:deviceNode
mutex	device.h	/^	pthread_mutex_t mutex;				\/* clock of current list *\/$/;"	m	struct:deviceList
next	device.h	/^	struct deviceNode* next;			\/* pointer points to next device which share the hash key with current device *\/$/;"	m	struct:deviceNode	typeref:struct:deviceNode::deviceNode
password	device.h	/^	char password[PASSWORD_SIZE+1];		\/* device password *\/ $/;"	m	struct:deviceNode
size	device.h	/^	int size;							\/* size of device table *\/$/;"	m	struct:deviceTable
table	device.h	/^	deviceList *table;					\/* pointer of device table *\/$/;"	m	struct:deviceTable
Pstack_empty	deviceMessage.c	/^int Pstack_empty(Pstack *ps)$/;"	f
Pstack_pop	deviceMessage.c	/^void Pstack_pop(Pstack *ps)$/;"	f
Pstack_push	deviceMessage.c	/^void Pstack_push(Pstack *ps, int k)$/;"	f
Pstack_top	deviceMessage.c	/^int Pstack_top(Pstack *ps)$/;"	f
analysisHeartBeatMessage	deviceMessage.c	/^void analysisHeartBeatMessage(char *message, char *deviceId, char *password)$/;"	f
analysisMessageToUser	deviceMessage.c	/^void analysisMessageToUser(char *recvBuffer, int *userSockfd, int *messageLen)$/;"	f
deviceEpollfd	deviceMessage.c	/^int deviceEpollfd;								\/* device epoll socket fd *\/$/;"	v
deviceListenPort	deviceMessage.c	/^const int deviceListenPort = 8000;				\/* device listen port *\/$/;"	v
deviceListenThread	deviceMessage.c	/^void *deviceListenThread()$/;"	f
deviceListenThreadId	deviceMessage.c	/^pthread_t deviceListenThreadId;		\/* device listen thread id *\/$/;"	v
deviceThreadInfoTable	deviceMessage.c	/^deviceThreadInfo deviceThreadInfoTable[DEVICE_MESSAGE_THREAD_SIZE+1];		\/* parameter table of threads which receive message from devcie *\/$/;"	v
freeDeviceThreadStack	deviceMessage.c	/^Pstack freeDeviceThreadStack;					\/* free stack of threads which receive message from device *\/$/;"	v
freeDeviceThreadStackMutex	deviceMessage.c	/^pthread_mutex_t	freeDeviceThreadStackMutex;		\/* clock of free stack of threads which receive message from device *\/$/;"	v
initDeviceListenThread	deviceMessage.c	/^int initDeviceListenThread()$/;"	f
initDeviceThreadPool	deviceMessage.c	/^int initDeviceThreadPool()$/;"	f
makeFeedBackMessage	deviceMessage.c	/^void makeFeedBackMessage(char *message, int feedbackType)$/;"	f
makeMessageHeadToUser	deviceMessage.c	/^void makeMessageHeadToUser(char *sendBuffer, int messageLen)$/;"	f
makeRegisterMessage	deviceMessage.c	/^void makeRegisterMessage(char *message, char *deviceId, char *password)$/;"	f
recvDeviceMessage	deviceMessage.c	/^void *recvDeviceMessage(int *id)$/;"	f
sendFeedbackMessage	deviceMessage.c	/^int sendFeedbackMessage(int sockfd, int feedbackType)$/;"	f
sendRegisterMessage	deviceMessage.c	/^int sendRegisterMessage(int sockfd, char *deviceId, char *password)$/;"	f
DEVCIE_MESSAGE_LISTEN_MAX	deviceMessage.h	36;"	d
DEVICE_MESSAGE_DEBUG	deviceMessage.h	31;"	d
DEVICE_MESSAGE_THREAD_SIZE	deviceMessage.h	35;"	d
MESSAGELEN_SIZE	deviceMessage.h	40;"	d
MESSAGE_HEAD_SIZE	deviceMessage.h	41;"	d
MESSAGE_TYPE_SIZE	deviceMessage.h	38;"	d
Pstack	deviceMessage.h	/^typedef struct Pstack$/;"	s
Pstack	deviceMessage.h	/^}Pstack;$/;"	t	typeref:struct:Pstack
USERSOCKFD_SIZE	deviceMessage.h	39;"	d
_DEVICEMESSAGE_H	deviceMessage.h	4;"	d
deviceThreadInfo	deviceMessage.h	/^typedef struct deviceThreadInfo$/;"	s
deviceThreadInfo	deviceMessage.h	/^}deviceThreadInfo;$/;"	t	typeref:struct:deviceThreadInfo
index	deviceMessage.h	/^	int index;						\/* id of current thread *\/$/;"	m	struct:deviceThreadInfo
q	deviceMessage.h	/^	int q[DEVICE_MESSAGE_THREAD_SIZE+1];$/;"	m	struct:Pstack
sockfd	deviceMessage.h	/^	int sockfd;						\/* socket fd  *\/$/;"	m	struct:deviceThreadInfo
threadId	deviceMessage.h	/^	pthread_t threadId;				\/* Pid of current thread *\/$/;"	m	struct:deviceThreadInfo
threadMutex	deviceMessage.h	/^	pthread_mutex_t threadMutex;	\/* clock of current thread *\/$/;"	m	struct:deviceThreadInfo
top	deviceMessage.h	/^	int top;$/;"	m	struct:Pstack
addEpollEvent	epollTools.c	/^int addEpollEvent(int epfd, int fd, struct epoll_event *event)$/;"	f
deleteEpollEvent	epollTools.c	/^int deleteEpollEvent(int epfd, int fd)$/;"	f
modifyEpollEvent	epollTools.c	/^int modifyEpollEvent(int epfd, int fd, struct epoll_event *event)$/;"	f
_EPOLLTOOLS_H	epollTools.h	4;"	d
hashFunction	hash.c	/^unsigned int hashFunction(const void *key, int keylen) $/;"	f
hashFunctionSeed	hash.c	/^static uint32_t hashFunctionSeed = 5381;$/;"	v	file:
_HASH_H	hash.h	4;"	d
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
allocateBlock	pooledBuffer.c	/^MemBlock *allocateBlock()$/;"	f
bufferPool	pooledBuffer.c	/^MemPool *bufferPool;		\/* buffer pool for the whole server *\/$/;"	v
decreaseBufferPool	pooledBuffer.c	/^int decreaseBufferPool(int number)$/;"	f
destroyBufferPool	pooledBuffer.c	/^void destroyBufferPool()$/;"	f
increaseBufferPool	pooledBuffer.c	/^int increaseBufferPool(int number)$/;"	f
initBufferPool	pooledBuffer.c	/^int initBufferPool(int bufferSize)$/;"	f
insertBlock	pooledBuffer.c	/^void insertBlock(MemBlock *newBlock)$/;"	f
socketBufferApplyNewBlock	pooledBuffer.c	/^MemBlock *socketBufferApplyNewBlock(socketBuffer *SOBuffer)$/;"	f
socketBufferFreeBlock	pooledBuffer.c	/^void socketBufferFreeBlock(socketBuffer *SOBuffer)$/;"	f
socketBufferInit	pooledBuffer.c	/^void socketBufferInit(socketBuffer *SOBuffer)$/;"	f
socketBufferReadMessage	pooledBuffer.c	/^int socketBufferReadMessage(int sockfd, socketBuffer *SOBuffer, int byteNumber)$/;"	f
socketBufferWriteMessage	pooledBuffer.c	/^int socketBufferWriteMessage(int sockfd, socketBuffer *SOBuffer)$/;"	f
BUFFER_POOL_SIZE	pooledBuffer.h	15;"	d
MEMBLOCK_SIZE	pooledBuffer.h	14;"	d
MemBlock	pooledBuffer.h	/^typedef struct MemBlock$/;"	s
MemBlock	pooledBuffer.h	/^}MemBlock; $/;"	t	typeref:struct:MemBlock
MemPool	pooledBuffer.h	/^typedef struct MemPool$/;"	s
MemPool	pooledBuffer.h	/^}MemPool;$/;"	t	typeref:struct:MemPool
_POOLED_BUFFER_H	pooledBuffer.h	4;"	d
blockNumber	pooledBuffer.h	/^	int blockNumber;		\/* number of MemBlocks in current buffer pool *\/$/;"	m	struct:MemPool
buffer	pooledBuffer.h	/^	char buffer[MEMBLOCK_SIZE];	\/* buffer of current block *\/$/;"	m	struct:MemBlock
head	pooledBuffer.h	/^	MemBlock *head;			\/* pointer to the first MemBlock in current buffer pool *\/$/;"	m	struct:MemPool
head	pooledBuffer.h	/^	MemBlock *head;			\/* pointer to the first MemBlock in those are used by current socket *\/$/;"	m	struct:socketBuffer
lastByte	pooledBuffer.h	/^	char *lastByte;			\/* position of the last byte *\/$/;"	m	struct:socketBuffer
leftByte	pooledBuffer.h	/^	int leftByte;			\/* number of bytes which haven't been used *\/$/;"	m	struct:socketBuffer
mutex	pooledBuffer.h	/^	pthread_mutex_t mutex;$/;"	m	struct:MemPool
next	pooledBuffer.h	/^	struct MemBlock *next;		\/* pointer to next block *\/$/;"	m	struct:MemBlock	typeref:struct:MemBlock::MemBlock
socketBuffer	pooledBuffer.h	/^typedef struct socketBuffer$/;"	s
socketBuffer	pooledBuffer.h	/^}socketBuffer;$/;"	t	typeref:struct:socketBuffer
tail	pooledBuffer.h	/^	MemBlock *tail;			\/* pointer to the last MemBlock in current buffer pool *\/$/;"	m	struct:MemPool
tail	pooledBuffer.h	/^	MemBlock *tail;			\/* pointer to the last MemBlock in those are used by current socket *\/$/;"	m	struct:socketBuffer
usedByte	pooledBuffer.h	/^	int usedByte;			\/* number of bytes which have been used *\/$/;"	m	struct:socketBuffer
IDRegister	register.c	/^void IDRegister(char *ip, int port, char *newID)$/;"	f
ustime	register.c	/^long long ustime() $/;"	f
_REGISTER_H	register.h	4;"	d
main	server.c	/^int main(int argc, char **argv) $/;"	f
_SERVER_H	server.h	3;"	d
createAndBind	socketTools.c	/^int createAndBind(int serverPort)$/;"	f
createAndConnect	socketTools.c	/^int createAndConnect(char *serverIP, int serverPort)$/;"	f
getPeerAddress	socketTools.c	/^void getPeerAddress(int fd, char *ip, int *port)$/;"	f
ipFormat	socketTools.c	/^void ipFormat(char *ip)$/;"	f
makeSocketNonBlocking	socketTools.c	/^int makeSocketNonBlocking (int sfd)$/;"	f
readNonBlocking	socketTools.c	/^int readNonBlocking(int fd, char * buf, int n)$/;"	f
readNonBlocking_n	socketTools.c	/^int readNonBlocking_n(int fd, char * buf, int n)$/;"	f
socketHasData	socketTools.c	/^int socketHasData(int sockfd)$/;"	f
writeNonBlocking	socketTools.c	/^int writeNonBlocking(int fd, char * buf, int n)$/;"	f
writeNonBlocking_n	socketTools.c	/^int writeNonBlocking_n(int fd, char * buf, int n)$/;"	f
_SOCKET_TOOL_H	socketTools.h	5;"	d
Ustack_empty	userMessage.c	/^int Ustack_empty(Ustack *ps)$/;"	f
Ustack_pop	userMessage.c	/^void Ustack_pop(Ustack *ps)$/;"	f
Ustack_push	userMessage.c	/^void Ustack_push(Ustack *ps, int k)$/;"	f
Ustack_top	userMessage.c	/^int Ustack_top(Ustack *ps)$/;"	f
analysisUserMessage	userMessage.c	/^void analysisUserMessage(char *recvBuffer, char *deviceId, int *messageLen)$/;"	f
freeUserThreadStack	userMessage.c	/^Ustack freeUserThreadStack;					\/* free stack of threads which receive message from users *\/$/;"	v
freeUserThreadStackMutex	userMessage.c	/^pthread_mutex_t	freeUserThreadStackMutex;	\/* clock of free stack of threads which receive message from users *\/$/;"	v
initUserListenThread	userMessage.c	/^int initUserListenThread()$/;"	f
initUserThreadPool	userMessage.c	/^int initUserThreadPool()$/;"	f
makeMessageHeadToDevice	userMessage.c	/^void makeMessageHeadToDevice(char *sendBuffer, int userSockfd, int messageLen)$/;"	f
recvUserMessage	userMessage.c	/^void *recvUserMessage(int *id)$/;"	f
userEpollfd	userMessage.c	/^int userEpollfd;								\/* user epoll fd *\/$/;"	v
userListenPort	userMessage.c	/^const int userListenPort = 8001;				\/* user listen port *\/$/;"	v
userListenThread	userMessage.c	/^void *userListenThread()$/;"	f
userThreadInfoTable	userMessage.c	/^userThreadInfo userThreadInfoTable[USER_MESSAGE_THREAD_SIZE+1];		\/* paramenter table of threads which receive message from users *\/$/;"	v
USER_MESSAGE_DEBUG	userMessage.h	26;"	d
USER_MESSAGE_LISTEN_MAX	userMessage.h	30;"	d
USER_MESSAGE_THREAD_SIZE	userMessage.h	29;"	d
Ustack	userMessage.h	/^typedef struct Ustack$/;"	s
Ustack	userMessage.h	/^}Ustack;$/;"	t	typeref:struct:Ustack
_USER_MESSAGE_H	userMessage.h	4;"	d
index	userMessage.h	/^	int index;						\/* id of current thread *\/$/;"	m	struct:userThreadInfo
q	userMessage.h	/^	int q[USER_MESSAGE_THREAD_SIZE+1];$/;"	m	struct:Ustack
sockfd	userMessage.h	/^	int sockfd;						\/* socket fd  *\/$/;"	m	struct:userThreadInfo
threadId	userMessage.h	/^	pthread_t threadId;				\/* Pid of current thread *\/$/;"	m	struct:userThreadInfo
threadMutex	userMessage.h	/^	pthread_mutex_t threadMutex;	\/* clock of current thread *\/$/;"	m	struct:userThreadInfo
top	userMessage.h	/^	int top;$/;"	m	struct:Ustack
userThreadInfo	userMessage.h	/^typedef struct userThreadInfo$/;"	s
userThreadInfo	userMessage.h	/^}userThreadInfo;$/;"	t	typeref:struct:userThreadInfo
